<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #sleepCover {
            position: absolute;
            top: 0;
            left: 0;
            width: 240px;
            height: 240px;
            background-color: black;
            display: none;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <input id="programPicker" type="file" onchange="loadProgramFile(this.files[0])">

    <div style="position: relative">
        <canvas id="display" width="240" height="240" style="background-color: red;"></canvas>
        <div id="sleepCover"></div>
    </div>

    <div id="performance"></div>

    <script>
        const myWorker = new Worker("infiniemu.worker.js");
        const programPicker = document.getElementById("programPicker");
        const display = document.getElementById("display");
        const sleepCover = document.getElementById("sleepCover");

        function loadProgramFile(file) {
            myWorker.postMessage({ type: "loadProgramFile", file });
            programPicker.remove();
        }

        let isMouseDown = false, isButtonDown = false;
        let hasSwiped = false;
        let mouseDownX, mouseDownY;

        display.addEventListener("contextmenu", e => {
            e.preventDefault();
        });

        display.addEventListener("mousedown", e => {
            e.preventDefault();

            if (e.button == 0) {
                isMouseDown = true;

                mouseDownX = e.offsetX;
                mouseDownY = e.offsetY;
            } else if (e.button == 2) {
                isButtonDown = true;

                myWorker.postMessage({ type: "pressButton" });
            }
        });
        display.addEventListener("mousemove", e => {
            if (!isMouseDown) {
                return;
            }

            e.preventDefault();

            const distX = e.offsetX - mouseDownX;
            const distY = e.offsetY - mouseDownY;
            const dist = Math.sqrt(distX * distX + distY * distY);

            if (dist > 50 && !hasSwiped) {
                hasSwiped = true;

                let gesture;

                if (Math.abs(distX) > Math.abs(distY)) {
                    gesture = distX > 0 ? 0x04 : 0x03;
                } else {
                    gesture = distY > 0 ? 0x01 : 0x02;
                }

                myWorker.postMessage({ type: "doTouch", gesture, x: e.offsetX, y: e.offsetY });
            }
        });
        display.addEventListener("mouseup", e => {
            e.preventDefault();

            if (isButtonDown) {
                isButtonDown = false;

                myWorker.postMessage({ type: "releaseButton" });
            }

            if (isMouseDown) {
                isMouseDown = false;

                if (hasSwiped) {
                    hasSwiped = false;
                    myWorker.postMessage({ type: "clearTouch" });
                } else {
                    myWorker.postMessage({ type: "doTouch", gesture: 0x05, x: e.offsetX, y: e.offsetY, duration: 200 });
                }
            }
        });

        myWorker.onmessage = function (e) {
            const { type, data } = e.data;

            switch (type) {
                case "performance":
                    document.getElementById("performance").innerText = data.ips.toFixed(0) + " instructions per second";
                    break;

                case "lcdSleeping":
                    console.log("sleeping", data);
                    sleepCover.style.display = data ? "block" : "none";
                    break;

                case "screenLoaded":
                    const ctx = display.getContext("2d");
                    const imageData = ctx.createImageData(240, 240);

                    const dv = new DataView(data.buffer.slice(data.byteOffset, data.byteOffset + data.length));

                    for (let x = 0; x < 240; x++) {
                        for (let y = 0; y < 240; y++) {
                            const pixel16 = dv.getUint16((y * 240 + x) * 2, false);

                            const r = (pixel16 >> 11) & 0x1f;
                            const g = (pixel16 >> 5) & 0x3f;
                            const b = pixel16 & 0x1f;

                            const r8 = Math.floor((r * 527 + 23) >> 6) & 0xFF;
                            const g8 = Math.floor((g * 259 + 33) >> 6) & 0xFF;
                            const b8 = Math.floor((b * 527 + 23) >> 6) & 0xFF;

                            const pixelIndex4 = (y * 240 + x) * 4;
                            imageData.data[pixelIndex4 + 0] = r8;
                            imageData.data[pixelIndex4 + 1] = g8;
                            imageData.data[pixelIndex4 + 2] = b8;
                            imageData.data[pixelIndex4 + 3] = 255;
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                    break;
            }
        };
    </script>
</body>

</html>